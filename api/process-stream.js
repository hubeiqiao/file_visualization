// Simple process-stream function for Vercel
module.exports = (req, res) => {
  // Set CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // Handle OPTIONS request (CORS preflight)
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }
  
  // Only allow POST requests
  if (req.method !== 'POST') {
    return res.status(405).json({
      success: false,
      error: 'Method not allowed. Use POST.'
    });
  }
  
  try {
    // Get content from request body
    const content = req.body && req.body.content;
    const fileType = req.body && req.body.file_type || 'txt';
    
    // Check if content is provided
    if (!content) {
      return res.status(400).json({
        success: false,
        error: 'Content is required'
      });
    }
    
    // For Vercel, we'll return a simplified HTML representation
    // since we can't use the actual Claude API without exposing API keys
    
    // Set response headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    
    // Send initial message
    res.write('event: message\n');
    res.write(`data: {"type":"start","message":"Starting HTML generation (Vercel serverless)"}\n\n`);
    
    // Generate a simple HTML representation
    const htmlContent = generateSimpleHTML(content, fileType);
    
    // Split the HTML into chunks to simulate streaming
    const chunks = splitIntoChunks(htmlContent, 500);
    
    // Send chunks with a small delay to simulate streaming
    let chunkIndex = 0;
    
    const sendNextChunk = () => {
      if (chunkIndex < chunks.length) {
        const chunk = chunks[chunkIndex];
        res.write('event: message\n');
        res.write(`data: {"type":"chunk","content":"${escapeJSON(chunk)}"}\n\n`);
        chunkIndex++;
        
        // Schedule next chunk
        setTimeout(sendNextChunk, 100);
      } else {
        // Send completion message
        res.write('event: message\n');
        res.write(`data: {"type":"end","message":"HTML generation complete"}\n\n`);
        res.end();
      }
    };
    
    // Start sending chunks
    sendNextChunk();
    
  } catch (error) {
    // Handle any errors
    console.error('Process stream error:', error);
    return res.status(500).json({
      success: false,
      error: `Error processing stream: ${error.message}`
    });
  }
};

// Generate a simple HTML representation of the content
function generateSimpleHTML(content, fileType) {
  // Create a basic HTML structure
  let html = `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>File Visualization</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
    pre { background-color: #f5f5f5; padding: 15px; border-radius: 5px; overflow-x: auto; }
    .highlight { background-color: #ffffcc; }
    h1, h2 { color: #333; }
    .container { max-width: 1200px; margin: 0 auto; }
  </style>
</head>
<body>
  <div class="container">
    <h1>File Visualization</h1>
    <p>This is a simplified HTML representation generated by the Vercel serverless function.</p>
    <p>For full functionality, please run the application locally.</p>
    
    <h2>Content Preview</h2>
    <pre>${escapeHTML(content)}</pre>
    
    <h2>File Type</h2>
    <p>${escapeHTML(fileType)}</p>
    
    <p><em>Note: This is a placeholder response. The actual Claude-powered visualization is only available when running locally with your API key.</em></p>
  </div>
</body>
</html>`;

  return html;
}

// Split text into chunks of specified size
function splitIntoChunks(text, chunkSize) {
  const chunks = [];
  for (let i = 0; i < text.length; i += chunkSize) {
    chunks.push(text.substring(i, i + chunkSize));
  }
  return chunks;
}

// Escape HTML special characters
function escapeHTML(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#039;');
}

// Escape special characters for JSON
function escapeJSON(text) {
  return text
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')
    .replace(/\f/g, '\\f');
} 